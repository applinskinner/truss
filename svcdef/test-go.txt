// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: test.proto

/*
	Package TEST is a generated protocol buffer package.

	It is generated from these files:
		test.proto

	It has these top-level messages:
		NestedTypeRequest
		NestedMessageA
		NestedMessageB
		NestedMessageC
		NestedTypeResponse
		MapTypeRequest
		NestedMapMessageA
		NestedMapMessageB
		NestedMapMessageC
		MapTypeResponse
		MapNestedMsg
		RepeatedTypes
*/
package TEST

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/TuneLab/truss/deftree/googlethirdparty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EnumType int32

const (
	EnumType_A EnumType = 0
	EnumType_B EnumType = 1
	EnumType_C EnumType = 2
)

var EnumType_name = map[int32]string{
	0: "A",
	1: "B",
	2: "C",
}
var EnumType_value = map[string]int32{
	"A": 0,
	"B": 1,
	"C": 2,
}

func (x EnumType) String() string {
	return proto.EnumName(EnumType_name, int32(x))
}
func (EnumType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTest, []int{0} }

type NestedTypeRequest struct {
	A *NestedMessageA   `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
	B []*NestedMessageB `protobuf:"bytes,17,rep,name=B" json:"B,omitempty"`
	C EnumType          `protobuf:"varint,18,opt,name=C,proto3,enum=TEST.EnumType" json:"C,omitempty"`
}

func (m *NestedTypeRequest) Reset()                    { *m = NestedTypeRequest{} }
func (m *NestedTypeRequest) String() string            { return proto.CompactTextString(m) }
func (*NestedTypeRequest) ProtoMessage()               {}
func (*NestedTypeRequest) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{0} }

func (m *NestedTypeRequest) GetA() *NestedMessageA {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *NestedTypeRequest) GetB() []*NestedMessageB {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *NestedTypeRequest) GetC() EnumType {
	if m != nil {
		return m.C
	}
	return EnumType_A
}

type NestedMessageA struct {
	A *NestedMessageC `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
}

func (m *NestedMessageA) Reset()                    { *m = NestedMessageA{} }
func (m *NestedMessageA) String() string            { return proto.CompactTextString(m) }
func (*NestedMessageA) ProtoMessage()               {}
func (*NestedMessageA) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{1} }

func (m *NestedMessageA) GetA() *NestedMessageC {
	if m != nil {
		return m.A
	}
	return nil
}

type NestedMessageB struct {
	A []*NestedMessageC `protobuf:"bytes,1,rep,name=A" json:"A,omitempty"`
}

func (m *NestedMessageB) Reset()                    { *m = NestedMessageB{} }
func (m *NestedMessageB) String() string            { return proto.CompactTextString(m) }
func (*NestedMessageB) ProtoMessage()               {}
func (*NestedMessageB) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{2} }

func (m *NestedMessageB) GetA() []*NestedMessageC {
	if m != nil {
		return m.A
	}
	return nil
}

type NestedMessageC struct {
	A int64 `protobuf:"varint,1,opt,name=A,proto3" json:"A,omitempty"`
}

func (m *NestedMessageC) Reset()                    { *m = NestedMessageC{} }
func (m *NestedMessageC) String() string            { return proto.CompactTextString(m) }
func (*NestedMessageC) ProtoMessage()               {}
func (*NestedMessageC) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{3} }

func (m *NestedMessageC) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

type NestedTypeResponse struct {
	A *NestedMessageA   `protobuf:"bytes,16,opt,name=A" json:"A,omitempty"`
	B []*NestedMessageB `protobuf:"bytes,17,rep,name=B" json:"B,omitempty"`
	C EnumType          `protobuf:"varint,18,opt,name=C,proto3,enum=TEST.EnumType" json:"C,omitempty"`
}

func (m *NestedTypeResponse) Reset()                    { *m = NestedTypeResponse{} }
func (m *NestedTypeResponse) String() string            { return proto.CompactTextString(m) }
func (*NestedTypeResponse) ProtoMessage()               {}
func (*NestedTypeResponse) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{4} }

func (m *NestedTypeResponse) GetA() *NestedMessageA {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *NestedTypeResponse) GetB() []*NestedMessageB {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *NestedTypeResponse) GetC() EnumType {
	if m != nil {
		return m.C
	}
	return EnumType_A
}

type MapTypeRequest struct {
	A   *NestedMapMessageA   `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
	B   []*NestedMapMessageB `protobuf:"bytes,2,rep,name=B" json:"B,omitempty"`
	AA  map[string]float64   `protobuf:"bytes,11,rep,name=AA" json:"AA,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BB  map[string]float32   `protobuf:"bytes,12,rep,name=BB" json:"BB,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	CC  map[string]int32     `protobuf:"bytes,13,rep,name=CC" json:"CC,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DD  map[string]int64     `protobuf:"bytes,14,rep,name=DD" json:"DD,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EE  map[string]uint32    `protobuf:"bytes,15,rep,name=EE" json:"EE,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FF  map[string]uint64    `protobuf:"bytes,16,rep,name=FF" json:"FF,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GG  map[string]int32     `protobuf:"bytes,17,rep,name=GG" json:"GG,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	HH  map[string]int64     `protobuf:"bytes,18,rep,name=HH" json:"HH,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	II  map[string]uint32    `protobuf:"bytes,19,rep,name=II" json:"II,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	JJ  map[string]uint64    `protobuf:"bytes,20,rep,name=JJ" json:"JJ,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	KK  map[string]int32     `protobuf:"bytes,21,rep,name=KK" json:"KK,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	LL  map[string]bool      `protobuf:"bytes,22,rep,name=LL" json:"LL,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MM  map[string]string    `protobuf:"bytes,23,rep,name=MM" json:"MM,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AAA map[int64]float64    `protobuf:"bytes,31,rep,name=AAA" json:"AAA,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BBB map[int64]float32    `protobuf:"bytes,32,rep,name=BBB" json:"BBB,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	CCC map[int64]int32      `protobuf:"bytes,33,rep,name=CCC" json:"CCC,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DDD map[int64]int64      `protobuf:"bytes,34,rep,name=DDD" json:"DDD,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EEE map[int64]uint32     `protobuf:"bytes,35,rep,name=EEE" json:"EEE,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FFF map[int64]uint64     `protobuf:"bytes,36,rep,name=FFF" json:"FFF,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GGG map[int64]int32      `protobuf:"bytes,37,rep,name=GGG" json:"GGG,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	HHH map[int64]int64      `protobuf:"bytes,38,rep,name=HHH" json:"HHH,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	III map[int64]uint32     `protobuf:"bytes,39,rep,name=III" json:"III,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	JJJ map[int64]uint64     `protobuf:"bytes,40,rep,name=JJJ" json:"JJJ,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	KKK map[int64]int32      `protobuf:"bytes,41,rep,name=KKK" json:"KKK,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	LLL map[int64]bool       `protobuf:"bytes,42,rep,name=LLL" json:"LLL,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MMM map[int64]string     `protobuf:"bytes,43,rep,name=MMM" json:"MMM,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MapTypeRequest) Reset()                    { *m = MapTypeRequest{} }
func (m *MapTypeRequest) String() string            { return proto.CompactTextString(m) }
func (*MapTypeRequest) ProtoMessage()               {}
func (*MapTypeRequest) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{5} }

func (m *MapTypeRequest) GetA() *NestedMapMessageA {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *MapTypeRequest) GetB() []*NestedMapMessageB {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *MapTypeRequest) GetAA() map[string]float64 {
	if m != nil {
		return m.AA
	}
	return nil
}

func (m *MapTypeRequest) GetBB() map[string]float32 {
	if m != nil {
		return m.BB
	}
	return nil
}

func (m *MapTypeRequest) GetCC() map[string]int32 {
	if m != nil {
		return m.CC
	}
	return nil
}

func (m *MapTypeRequest) GetDD() map[string]int64 {
	if m != nil {
		return m.DD
	}
	return nil
}

func (m *MapTypeRequest) GetEE() map[string]uint32 {
	if m != nil {
		return m.EE
	}
	return nil
}

func (m *MapTypeRequest) GetFF() map[string]uint64 {
	if m != nil {
		return m.FF
	}
	return nil
}

func (m *MapTypeRequest) GetGG() map[string]int32 {
	if m != nil {
		return m.GG
	}
	return nil
}

func (m *MapTypeRequest) GetHH() map[string]int64 {
	if m != nil {
		return m.HH
	}
	return nil
}

func (m *MapTypeRequest) GetII() map[string]uint32 {
	if m != nil {
		return m.II
	}
	return nil
}

func (m *MapTypeRequest) GetJJ() map[string]uint64 {
	if m != nil {
		return m.JJ
	}
	return nil
}

func (m *MapTypeRequest) GetKK() map[string]int32 {
	if m != nil {
		return m.KK
	}
	return nil
}

func (m *MapTypeRequest) GetLL() map[string]bool {
	if m != nil {
		return m.LL
	}
	return nil
}

func (m *MapTypeRequest) GetMM() map[string]string {
	if m != nil {
		return m.MM
	}
	return nil
}

func (m *MapTypeRequest) GetAAA() map[int64]float64 {
	if m != nil {
		return m.AAA
	}
	return nil
}

func (m *MapTypeRequest) GetBBB() map[int64]float32 {
	if m != nil {
		return m.BBB
	}
	return nil
}

func (m *MapTypeRequest) GetCCC() map[int64]int32 {
	if m != nil {
		return m.CCC
	}
	return nil
}

func (m *MapTypeRequest) GetDDD() map[int64]int64 {
	if m != nil {
		return m.DDD
	}
	return nil
}

func (m *MapTypeRequest) GetEEE() map[int64]uint32 {
	if m != nil {
		return m.EEE
	}
	return nil
}

func (m *MapTypeRequest) GetFFF() map[int64]uint64 {
	if m != nil {
		return m.FFF
	}
	return nil
}

func (m *MapTypeRequest) GetGGG() map[int64]int32 {
	if m != nil {
		return m.GGG
	}
	return nil
}

func (m *MapTypeRequest) GetHHH() map[int64]int64 {
	if m != nil {
		return m.HHH
	}
	return nil
}

func (m *MapTypeRequest) GetIII() map[int64]uint32 {
	if m != nil {
		return m.III
	}
	return nil
}

func (m *MapTypeRequest) GetJJJ() map[int64]uint64 {
	if m != nil {
		return m.JJJ
	}
	return nil
}

func (m *MapTypeRequest) GetKKK() map[int64]int32 {
	if m != nil {
		return m.KKK
	}
	return nil
}

func (m *MapTypeRequest) GetLLL() map[int64]bool {
	if m != nil {
		return m.LLL
	}
	return nil
}

func (m *MapTypeRequest) GetMMM() map[int64]string {
	if m != nil {
		return m.MMM
	}
	return nil
}

type NestedMapMessageA struct {
	A *NestedMapMessageC `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
}

func (m *NestedMapMessageA) Reset()                    { *m = NestedMapMessageA{} }
func (m *NestedMapMessageA) String() string            { return proto.CompactTextString(m) }
func (*NestedMapMessageA) ProtoMessage()               {}
func (*NestedMapMessageA) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{6} }

func (m *NestedMapMessageA) GetA() *NestedMapMessageC {
	if m != nil {
		return m.A
	}
	return nil
}

type NestedMapMessageB struct {
	A []*NestedMapMessageC `protobuf:"bytes,1,rep,name=A" json:"A,omitempty"`
}

func (m *NestedMapMessageB) Reset()                    { *m = NestedMapMessageB{} }
func (m *NestedMapMessageB) String() string            { return proto.CompactTextString(m) }
func (*NestedMapMessageB) ProtoMessage()               {}
func (*NestedMapMessageB) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{7} }

func (m *NestedMapMessageB) GetA() []*NestedMapMessageC {
	if m != nil {
		return m.A
	}
	return nil
}

type NestedMapMessageC struct {
	A map[string]string `protobuf:"bytes,1,rep,name=A" json:"A,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NestedMapMessageC) Reset()                    { *m = NestedMapMessageC{} }
func (m *NestedMapMessageC) String() string            { return proto.CompactTextString(m) }
func (*NestedMapMessageC) ProtoMessage()               {}
func (*NestedMapMessageC) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{8} }

func (m *NestedMapMessageC) GetA() map[string]string {
	if m != nil {
		return m.A
	}
	return nil
}

type MapTypeResponse struct {
	A   *NestedMapMessageA   `protobuf:"bytes,1,opt,name=A" json:"A,omitempty"`
	B   []*NestedMapMessageB `protobuf:"bytes,2,rep,name=B" json:"B,omitempty"`
	AA  map[string]float64   `protobuf:"bytes,11,rep,name=AA" json:"AA,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BB  map[string]float32   `protobuf:"bytes,12,rep,name=BB" json:"BB,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	CC  map[string]int32     `protobuf:"bytes,13,rep,name=CC" json:"CC,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DD  map[string]int64     `protobuf:"bytes,14,rep,name=DD" json:"DD,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EE  map[string]uint32    `protobuf:"bytes,15,rep,name=EE" json:"EE,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FF  map[string]uint64    `protobuf:"bytes,16,rep,name=FF" json:"FF,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GG  map[string]int32     `protobuf:"bytes,17,rep,name=GG" json:"GG,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	HH  map[string]int64     `protobuf:"bytes,18,rep,name=HH" json:"HH,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	II  map[string]uint32    `protobuf:"bytes,19,rep,name=II" json:"II,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	JJ  map[string]uint64    `protobuf:"bytes,20,rep,name=JJ" json:"JJ,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	KK  map[string]int32     `protobuf:"bytes,21,rep,name=KK" json:"KK,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	LL  map[string]bool      `protobuf:"bytes,22,rep,name=LL" json:"LL,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MM  map[string]string    `protobuf:"bytes,23,rep,name=MM" json:"MM,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AAA map[int64]float64    `protobuf:"bytes,31,rep,name=AAA" json:"AAA,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BBB map[int64]float32    `protobuf:"bytes,32,rep,name=BBB" json:"BBB,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	CCC map[int64]int32      `protobuf:"bytes,33,rep,name=CCC" json:"CCC,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DDD map[int64]int64      `protobuf:"bytes,34,rep,name=DDD" json:"DDD,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	EEE map[int64]uint32     `protobuf:"bytes,35,rep,name=EEE" json:"EEE,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FFF map[int64]uint64     `protobuf:"bytes,36,rep,name=FFF" json:"FFF,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	GGG map[int64]int32      `protobuf:"bytes,37,rep,name=GGG" json:"GGG,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	HHH map[int64]int64      `protobuf:"bytes,38,rep,name=HHH" json:"HHH,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	III map[int64]uint32     `protobuf:"bytes,39,rep,name=III" json:"III,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	JJJ map[int64]uint64     `protobuf:"bytes,40,rep,name=JJJ" json:"JJJ,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	KKK map[int64]int32      `protobuf:"bytes,41,rep,name=KKK" json:"KKK,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	LLL map[int64]bool       `protobuf:"bytes,42,rep,name=LLL" json:"LLL,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MMM map[int64]string     `protobuf:"bytes,43,rep,name=MMM" json:"MMM,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MapTypeResponse) Reset()                    { *m = MapTypeResponse{} }
func (m *MapTypeResponse) String() string            { return proto.CompactTextString(m) }
func (*MapTypeResponse) ProtoMessage()               {}
func (*MapTypeResponse) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{9} }

func (m *MapTypeResponse) GetA() *NestedMapMessageA {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *MapTypeResponse) GetB() []*NestedMapMessageB {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *MapTypeResponse) GetAA() map[string]float64 {
	if m != nil {
		return m.AA
	}
	return nil
}

func (m *MapTypeResponse) GetBB() map[string]float32 {
	if m != nil {
		return m.BB
	}
	return nil
}

func (m *MapTypeResponse) GetCC() map[string]int32 {
	if m != nil {
		return m.CC
	}
	return nil
}

func (m *MapTypeResponse) GetDD() map[string]int64 {
	if m != nil {
		return m.DD
	}
	return nil
}

func (m *MapTypeResponse) GetEE() map[string]uint32 {
	if m != nil {
		return m.EE
	}
	return nil
}

func (m *MapTypeResponse) GetFF() map[string]uint64 {
	if m != nil {
		return m.FF
	}
	return nil
}

func (m *MapTypeResponse) GetGG() map[string]int32 {
	if m != nil {
		return m.GG
	}
	return nil
}

func (m *MapTypeResponse) GetHH() map[string]int64 {
	if m != nil {
		return m.HH
	}
	return nil
}

func (m *MapTypeResponse) GetII() map[string]uint32 {
	if m != nil {
		return m.II
	}
	return nil
}

func (m *MapTypeResponse) GetJJ() map[string]uint64 {
	if m != nil {
		return m.JJ
	}
	return nil
}

func (m *MapTypeResponse) GetKK() map[string]int32 {
	if m != nil {
		return m.KK
	}
	return nil
}

func (m *MapTypeResponse) GetLL() map[string]bool {
	if m != nil {
		return m.LL
	}
	return nil
}

func (m *MapTypeResponse) GetMM() map[string]string {
	if m != nil {
		return m.MM
	}
	return nil
}

func (m *MapTypeResponse) GetAAA() map[int64]float64 {
	if m != nil {
		return m.AAA
	}
	return nil
}

func (m *MapTypeResponse) GetBBB() map[int64]float32 {
	if m != nil {
		return m.BBB
	}
	return nil
}

func (m *MapTypeResponse) GetCCC() map[int64]int32 {
	if m != nil {
		return m.CCC
	}
	return nil
}

func (m *MapTypeResponse) GetDDD() map[int64]int64 {
	if m != nil {
		return m.DDD
	}
	return nil
}

func (m *MapTypeResponse) GetEEE() map[int64]uint32 {
	if m != nil {
		return m.EEE
	}
	return nil
}

func (m *MapTypeResponse) GetFFF() map[int64]uint64 {
	if m != nil {
		return m.FFF
	}
	return nil
}

func (m *MapTypeResponse) GetGGG() map[int64]int32 {
	if m != nil {
		return m.GGG
	}
	return nil
}

func (m *MapTypeResponse) GetHHH() map[int64]int64 {
	if m != nil {
		return m.HHH
	}
	return nil
}

func (m *MapTypeResponse) GetIII() map[int64]uint32 {
	if m != nil {
		return m.III
	}
	return nil
}

func (m *MapTypeResponse) GetJJJ() map[int64]uint64 {
	if m != nil {
		return m.JJJ
	}
	return nil
}

func (m *MapTypeResponse) GetKKK() map[int64]int32 {
	if m != nil {
		return m.KKK
	}
	return nil
}

func (m *MapTypeResponse) GetLLL() map[int64]bool {
	if m != nil {
		return m.LLL
	}
	return nil
}

func (m *MapTypeResponse) GetMMM() map[int64]string {
	if m != nil {
		return m.MMM
	}
	return nil
}

type MapNestedMsg struct {
	Beta map[int64]*NestedMessageA `protobuf:"bytes,2,rep,name=Beta" json:"Beta,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MapNestedMsg) Reset()                    { *m = MapNestedMsg{} }
func (m *MapNestedMsg) String() string            { return proto.CompactTextString(m) }
func (*MapNestedMsg) ProtoMessage()               {}
func (*MapNestedMsg) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{10} }

func (m *MapNestedMsg) GetBeta() map[int64]*NestedMessageA {
	if m != nil {
		return m.Beta
	}
	return nil
}

type RepeatedTypes struct {
	AA []int64    `protobuf:"varint,1,rep,packed,name=AA" json:"AA,omitempty"`
	BB []string   `protobuf:"bytes,2,rep,name=BB" json:"BB,omitempty"`
	CC []EnumType `protobuf:"varint,3,rep,packed,name=CC,enum=TEST.EnumType" json:"CC,omitempty"`
}

func (m *RepeatedTypes) Reset()                    { *m = RepeatedTypes{} }
func (m *RepeatedTypes) String() string            { return proto.CompactTextString(m) }
func (*RepeatedTypes) ProtoMessage()               {}
func (*RepeatedTypes) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{11} }

func (m *RepeatedTypes) GetAA() []int64 {
	if m != nil {
		return m.AA
	}
	return nil
}

func (m *RepeatedTypes) GetBB() []string {
	if m != nil {
		return m.BB
	}
	return nil
}

func (m *RepeatedTypes) GetCC() []EnumType {
	if m != nil {
		return m.CC
	}
	return nil
}

func init() {
	proto.RegisterType((*NestedTypeRequest)(nil), "TEST.NestedTypeRequest")
	proto.RegisterType((*NestedMessageA)(nil), "TEST.NestedMessageA")
	proto.RegisterType((*NestedMessageB)(nil), "TEST.NestedMessageB")
	proto.RegisterType((*NestedMessageC)(nil), "TEST.NestedMessageC")
	proto.RegisterType((*NestedTypeResponse)(nil), "TEST.NestedTypeResponse")
	proto.RegisterType((*MapTypeRequest)(nil), "TEST.MapTypeRequest")
	proto.RegisterType((*NestedMapMessageA)(nil), "TEST.NestedMapMessageA")
	proto.RegisterType((*NestedMapMessageB)(nil), "TEST.NestedMapMessageB")
	proto.RegisterType((*NestedMapMessageC)(nil), "TEST.NestedMapMessageC")
	proto.RegisterType((*MapTypeResponse)(nil), "TEST.MapTypeResponse")
	proto.RegisterType((*MapNestedMsg)(nil), "TEST.MapNestedMsg")
	proto.RegisterType((*RepeatedTypes)(nil), "TEST.RepeatedTypes")
	proto.RegisterEnum("TEST.EnumType", EnumType_name, EnumType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Map service

type MapClient interface {
	GetMap(ctx context.Context, in *MapTypeRequest, opts ...grpc.CallOption) (*MapTypeResponse, error)
	PostMap(ctx context.Context, in *MapTypeRequest, opts ...grpc.CallOption) (*MapTypeRequest, error)
	GetNested(ctx context.Context, in *NestedTypeRequest, opts ...grpc.CallOption) (*NestedTypeResponse, error)
	PostNested(ctx context.Context, in *NestedTypeRequest, opts ...grpc.CallOption) (*NestedTypeRequest, error)
}

type mapClient struct {
	cc *grpc.ClientConn
}

func NewMapClient(cc *grpc.ClientConn) MapClient {
	return &mapClient{cc}
}

func (c *mapClient) GetMap(ctx context.Context, in *MapTypeRequest, opts ...grpc.CallOption) (*MapTypeResponse, error) {
	out := new(MapTypeResponse)
	err := grpc.Invoke(ctx, "/TEST.Map/GetMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) PostMap(ctx context.Context, in *MapTypeRequest, opts ...grpc.CallOption) (*MapTypeRequest, error) {
	out := new(MapTypeRequest)
	err := grpc.Invoke(ctx, "/TEST.Map/PostMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) GetNested(ctx context.Context, in *NestedTypeRequest, opts ...grpc.CallOption) (*NestedTypeResponse, error) {
	out := new(NestedTypeResponse)
	err := grpc.Invoke(ctx, "/TEST.Map/GetNested", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) PostNested(ctx context.Context, in *NestedTypeRequest, opts ...grpc.CallOption) (*NestedTypeRequest, error) {
	out := new(NestedTypeRequest)
	err := grpc.Invoke(ctx, "/TEST.Map/PostNested", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Map service

type MapServer interface {
	GetMap(context.Context, *MapTypeRequest) (*MapTypeResponse, error)
	PostMap(context.Context, *MapTypeRequest) (*MapTypeRequest, error)
	GetNested(context.Context, *NestedTypeRequest) (*NestedTypeResponse, error)
	PostNested(context.Context, *NestedTypeRequest) (*NestedTypeRequest, error)
}

func RegisterMapServer(s *grpc.Server, srv MapServer) {
	s.RegisterService(&_Map_serviceDesc, srv)
}

func _Map_GetMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).GetMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TEST.Map/GetMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).GetMap(ctx, req.(*MapTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_PostMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).PostMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TEST.Map/PostMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).PostMap(ctx, req.(*MapTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_GetNested_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NestedTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).GetNested(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TEST.Map/GetNested",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).GetNested(ctx, req.(*NestedTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_PostNested_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NestedTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).PostNested(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TEST.Map/PostNested",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).PostNested(ctx, req.(*NestedTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Map_serviceDesc = grpc.ServiceDesc{
	ServiceName: "TEST.Map",
	HandlerType: (*MapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMap",
			Handler:    _Map_GetMap_Handler,
		},
		{
			MethodName: "PostMap",
			Handler:    _Map_PostMap_Handler,
		},
		{
			MethodName: "GetNested",
			Handler:    _Map_GetNested_Handler,
		},
		{
			MethodName: "PostNested",
			Handler:    _Map_PostNested_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "test.proto",
}

func (m *NestedTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n1, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.B) > 0 {
		for _, msg := range m.B {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.C != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.C))
	}
	return i, nil
}

func (m *NestedMessageA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMessageA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n2, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *NestedMessageB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMessageB) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.A) > 0 {
		for _, msg := range m.A {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NestedMessageC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMessageC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A))
	}
	return i, nil
}

func (m *NestedTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n3, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.B) > 0 {
		for _, msg := range m.B {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.C != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.C))
	}
	return i, nil
}

func (m *MapTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n4, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.B) > 0 {
		for _, msg := range m.B {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AA) > 0 {
		for k, _ := range m.AA {
			dAtA[i] = 0x5a
			i++
			v := m.AA[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(math.Float64bits(float64(v))))
		}
	}
	if len(m.BB) > 0 {
		for k, _ := range m.BB {
			dAtA[i] = 0x62
			i++
			v := m.BB[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	if len(m.CC) > 0 {
		for k, _ := range m.CC {
			dAtA[i] = 0x6a
			i++
			v := m.CC[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.DD) > 0 {
		for k, _ := range m.DD {
			dAtA[i] = 0x72
			i++
			v := m.DD[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.EE) > 0 {
		for k, _ := range m.EE {
			dAtA[i] = 0x7a
			i++
			v := m.EE[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.FF) > 0 {
		for k, _ := range m.FF {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.FF[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.GG) > 0 {
		for k, _ := range m.GG {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.GG[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
		}
	}
	if len(m.HH) > 0 {
		for k, _ := range m.HH {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			v := m.HH[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
		}
	}
	if len(m.II) > 0 {
		for k, _ := range m.II {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.II[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.JJ) > 0 {
		for k, _ := range m.JJ {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.JJ[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(v))
		}
	}
	if len(m.KK) > 0 {
		for k, _ := range m.KK {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.KK[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.LL) > 0 {
		for k, _ := range m.LL {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.LL[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 1
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.MM) > 0 {
		for k, _ := range m.MM {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.MM[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.AAA) > 0 {
		for k, _ := range m.AAA {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.AAA[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(math.Float64bits(float64(v))))
		}
	}
	if len(m.BBB) > 0 {
		for k, _ := range m.BBB {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			v := m.BBB[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	if len(m.CCC) > 0 {
		for k, _ := range m.CCC {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			v := m.CCC[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.DDD) > 0 {
		for k, _ := range m.DDD {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			v := m.DDD[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.EEE) > 0 {
		for k, _ := range m.EEE {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			v := m.EEE[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.FFF) > 0 {
		for k, _ := range m.FFF {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			v := m.FFF[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.GGG) > 0 {
		for k, _ := range m.GGG {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.GGG[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
		}
	}
	if len(m.HHH) > 0 {
		for k, _ := range m.HHH {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			v := m.HHH[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
		}
	}
	if len(m.III) > 0 {
		for k, _ := range m.III {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x2
			i++
			v := m.III[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.JJJ) > 0 {
		for k, _ := range m.JJJ {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x2
			i++
			v := m.JJJ[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(v))
		}
	}
	if len(m.KKK) > 0 {
		for k, _ := range m.KKK {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x2
			i++
			v := m.KKK[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.LLL) > 0 {
		for k, _ := range m.LLL {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x2
			i++
			v := m.LLL[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 1
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.MMM) > 0 {
		for k, _ := range m.MMM {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			v := m.MMM[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *NestedMapMessageA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMapMessageA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n5, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *NestedMapMessageB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMapMessageB) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.A) > 0 {
		for _, msg := range m.A {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NestedMapMessageC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedMapMessageC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.A) > 0 {
		for k, _ := range m.A {
			dAtA[i] = 0xa
			i++
			v := m.A[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *MapTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.A != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.A.Size()))
		n6, err := m.A.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.B) > 0 {
		for _, msg := range m.B {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AA) > 0 {
		for k, _ := range m.AA {
			dAtA[i] = 0x5a
			i++
			v := m.AA[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(math.Float64bits(float64(v))))
		}
	}
	if len(m.BB) > 0 {
		for k, _ := range m.BB {
			dAtA[i] = 0x62
			i++
			v := m.BB[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	if len(m.CC) > 0 {
		for k, _ := range m.CC {
			dAtA[i] = 0x6a
			i++
			v := m.CC[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.DD) > 0 {
		for k, _ := range m.DD {
			dAtA[i] = 0x72
			i++
			v := m.DD[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.EE) > 0 {
		for k, _ := range m.EE {
			dAtA[i] = 0x7a
			i++
			v := m.EE[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.FF) > 0 {
		for k, _ := range m.FF {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.FF[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.GG) > 0 {
		for k, _ := range m.GG {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.GG[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
		}
	}
	if len(m.HH) > 0 {
		for k, _ := range m.HH {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			v := m.HH[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
		}
	}
	if len(m.II) > 0 {
		for k, _ := range m.II {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.II[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.JJ) > 0 {
		for k, _ := range m.JJ {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			v := m.JJ[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(v))
		}
	}
	if len(m.KK) > 0 {
		for k, _ := range m.KK {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.KK[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.LL) > 0 {
		for k, _ := range m.LL {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.LL[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 1
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.MM) > 0 {
		for k, _ := range m.MM {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			v := m.MM[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.AAA) > 0 {
		for k, _ := range m.AAA {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.AAA[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(math.Float64bits(float64(v))))
		}
	}
	if len(m.BBB) > 0 {
		for k, _ := range m.BBB {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			v := m.BBB[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(math.Float32bits(float32(v))))
		}
	}
	if len(m.CCC) > 0 {
		for k, _ := range m.CCC {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			v := m.CCC[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.DDD) > 0 {
		for k, _ := range m.DDD {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			v := m.DDD[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.EEE) > 0 {
		for k, _ := range m.EEE {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			v := m.EEE[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.FFF) > 0 {
		for k, _ := range m.FFF {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			v := m.FFF[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.GGG) > 0 {
		for k, _ := range m.GGG {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.GGG[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint32(v)<<1)^uint32((v>>31))))
		}
	}
	if len(m.HHH) > 0 {
		for k, _ := range m.HHH {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			v := m.HHH[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64((uint64(v)<<1)^uint64((v>>63))))
		}
	}
	if len(m.III) > 0 {
		for k, _ := range m.III {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x2
			i++
			v := m.III[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.JJJ) > 0 {
		for k, _ := range m.JJJ {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x2
			i++
			v := m.JJJ[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 8
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x11
			i++
			i = encodeFixed64Test(dAtA, i, uint64(v))
		}
	}
	if len(m.KKK) > 0 {
		for k, _ := range m.KKK {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x2
			i++
			v := m.KKK[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 4
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x15
			i++
			i = encodeFixed32Test(dAtA, i, uint32(v))
		}
	}
	if len(m.LLL) > 0 {
		for k, _ := range m.LLL {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x2
			i++
			v := m.LLL[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + 1
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.MMM) > 0 {
		for k, _ := range m.MMM {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			v := m.MMM[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *MapNestedMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapNestedMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Beta) > 0 {
		for k, _ := range m.Beta {
			dAtA[i] = 0x12
			i++
			v := m.Beta[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + sovTest(uint64(k)) + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *RepeatedTypes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedTypes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AA) > 0 {
		dAtA9 := make([]byte, len(m.AA)*10)
		var j8 int
		for _, num1 := range m.AA {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.BB) > 0 {
		for _, s := range m.BB {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CC) > 0 {
		dAtA11 := make([]byte, len(m.CC)*10)
		var j10 int
		for _, num := range m.CC {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTest(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func encodeFixed64Test(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Test(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTest(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NestedTypeRequest) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.B) > 0 {
		for _, e := range m.B {
			l = e.Size()
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if m.C != 0 {
		n += 2 + sovTest(uint64(m.C))
	}
	return n
}

func (m *NestedMessageA) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}

func (m *NestedMessageB) Size() (n int) {
	var l int
	_ = l
	if len(m.A) > 0 {
		for _, e := range m.A {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	return n
}

func (m *NestedMessageC) Size() (n int) {
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovTest(uint64(m.A))
	}
	return n
}

func (m *NestedTypeResponse) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.B) > 0 {
		for _, e := range m.B {
			l = e.Size()
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if m.C != 0 {
		n += 2 + sovTest(uint64(m.C))
	}
	return n
}

func (m *MapTypeRequest) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.B) > 0 {
		for _, e := range m.B {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if len(m.AA) > 0 {
		for k, v := range m.AA {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.BB) > 0 {
		for k, v := range m.BB {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.CC) > 0 {
		for k, v := range m.CC {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.DD) > 0 {
		for k, v := range m.DD {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.EE) > 0 {
		for k, v := range m.EE {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.FF) > 0 {
		for k, v := range m.FF {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.GG) > 0 {
		for k, v := range m.GG {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.HH) > 0 {
		for k, v := range m.HH {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.II) > 0 {
		for k, v := range m.II {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.JJ) > 0 {
		for k, v := range m.JJ {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.KK) > 0 {
		for k, v := range m.KK {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.LL) > 0 {
		for k, v := range m.LL {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MM) > 0 {
		for k, v := range m.MM {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.AAA) > 0 {
		for k, v := range m.AAA {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.BBB) > 0 {
		for k, v := range m.BBB {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.CCC) > 0 {
		for k, v := range m.CCC {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.DDD) > 0 {
		for k, v := range m.DDD {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.EEE) > 0 {
		for k, v := range m.EEE {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.FFF) > 0 {
		for k, v := range m.FFF {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.GGG) > 0 {
		for k, v := range m.GGG {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.HHH) > 0 {
		for k, v := range m.HHH {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.III) > 0 {
		for k, v := range m.III {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.JJJ) > 0 {
		for k, v := range m.JJJ {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.KKK) > 0 {
		for k, v := range m.KKK {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.LLL) > 0 {
		for k, v := range m.LLL {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 1
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MMM) > 0 {
		for k, v := range m.MMM {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NestedMapMessageA) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}

func (m *NestedMapMessageB) Size() (n int) {
	var l int
	_ = l
	if len(m.A) > 0 {
		for _, e := range m.A {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	return n
}

func (m *NestedMapMessageC) Size() (n int) {
	var l int
	_ = l
	if len(m.A) > 0 {
		for k, v := range m.A {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MapTypeResponse) Size() (n int) {
	var l int
	_ = l
	if m.A != nil {
		l = m.A.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.B) > 0 {
		for _, e := range m.B {
			l = e.Size()
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if len(m.AA) > 0 {
		for k, v := range m.AA {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.BB) > 0 {
		for k, v := range m.BB {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.CC) > 0 {
		for k, v := range m.CC {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.DD) > 0 {
		for k, v := range m.DD {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.EE) > 0 {
		for k, v := range m.EE {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.FF) > 0 {
		for k, v := range m.FF {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.GG) > 0 {
		for k, v := range m.GG {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.HH) > 0 {
		for k, v := range m.HH {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.II) > 0 {
		for k, v := range m.II {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.JJ) > 0 {
		for k, v := range m.JJ {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.KK) > 0 {
		for k, v := range m.KK {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.LL) > 0 {
		for k, v := range m.LL {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MM) > 0 {
		for k, v := range m.MM {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.AAA) > 0 {
		for k, v := range m.AAA {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.BBB) > 0 {
		for k, v := range m.BBB {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.CCC) > 0 {
		for k, v := range m.CCC {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.DDD) > 0 {
		for k, v := range m.DDD {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.EEE) > 0 {
		for k, v := range m.EEE {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.FFF) > 0 {
		for k, v := range m.FFF {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.GGG) > 0 {
		for k, v := range m.GGG {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.HHH) > 0 {
		for k, v := range m.HHH {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + sozTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.III) > 0 {
		for k, v := range m.III {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.JJJ) > 0 {
		for k, v := range m.JJJ {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 8
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.KKK) > 0 {
		for k, v := range m.KKK {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 4
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.LLL) > 0 {
		for k, v := range m.LLL {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + 1
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MMM) > 0 {
		for k, v := range m.MMM {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MapNestedMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Beta) > 0 {
		for k, v := range m.Beta {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + sovTest(uint64(k)) + l
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RepeatedTypes) Size() (n int) {
	var l int
	_ = l
	if len(m.AA) > 0 {
		l = 0
		for _, e := range m.AA {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if len(m.BB) > 0 {
		for _, s := range m.BB {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if len(m.CC) > 0 {
		l = 0
		for _, e := range m.CC {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	return n
}

func sovTest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTest(x uint64) (n int) {
	return sovTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NestedTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMessageA{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B = append(m.B, &NestedMessageB{})
			if err := m.B[len(m.B)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= (EnumType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMessageA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMessageA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMessageA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMessageC{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMessageB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMessageB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMessageB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = append(m.A, &NestedMessageC{})
			if err := m.A[len(m.A)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMessageC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMessageC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMessageC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMessageA{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B = append(m.B, &NestedMessageB{})
			if err := m.B[len(m.B)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= (EnumType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMapMessageA{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B = append(m.B, &NestedMapMessageB{})
			if err := m.B[len(m.B)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AA == nil {
				m.AA = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvaluetemp = uint64(dAtA[iNdEx-8])
					mapvaluetemp |= uint64(dAtA[iNdEx-7]) << 8
					mapvaluetemp |= uint64(dAtA[iNdEx-6]) << 16
					mapvaluetemp |= uint64(dAtA[iNdEx-5]) << 24
					mapvaluetemp |= uint64(dAtA[iNdEx-4]) << 32
					mapvaluetemp |= uint64(dAtA[iNdEx-3]) << 40
					mapvaluetemp |= uint64(dAtA[iNdEx-2]) << 48
					mapvaluetemp |= uint64(dAtA[iNdEx-1]) << 56
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AA[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BB == nil {
				m.BB = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvaluetemp = uint32(dAtA[iNdEx-4])
					mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
					mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
					mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BB[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CC == nil {
				m.CC = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CC[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DD == nil {
				m.DD = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DD[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EE == nil {
				m.EE = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EE[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FF == nil {
				m.FF = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FF[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GG == nil {
				m.GG = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GG[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HH == nil {
				m.HH = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HH[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field II", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.II == nil {
				m.II = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = uint32(dAtA[iNdEx-4])
					mapvalue |= uint32(dAtA[iNdEx-3]) << 8
					mapvalue |= uint32(dAtA[iNdEx-2]) << 16
					mapvalue |= uint32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.II[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JJ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JJ == nil {
				m.JJ = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvalue = uint64(dAtA[iNdEx-8])
					mapvalue |= uint64(dAtA[iNdEx-7]) << 8
					mapvalue |= uint64(dAtA[iNdEx-6]) << 16
					mapvalue |= uint64(dAtA[iNdEx-5]) << 24
					mapvalue |= uint64(dAtA[iNdEx-4]) << 32
					mapvalue |= uint64(dAtA[iNdEx-3]) << 40
					mapvalue |= uint64(dAtA[iNdEx-2]) << 48
					mapvalue |= uint64(dAtA[iNdEx-1]) << 56
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JJ[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KK == nil {
				m.KK = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = int32(dAtA[iNdEx-4])
					mapvalue |= int32(dAtA[iNdEx-3]) << 8
					mapvalue |= int32(dAtA[iNdEx-2]) << 16
					mapvalue |= int32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KK[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LL == nil {
				m.LL = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LL[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MM == nil {
				m.MM = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MM[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AAA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AAA == nil {
				m.AAA = make(map[int64]float64)
			}
			var mapkey int64
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvaluetemp = uint64(dAtA[iNdEx-8])
					mapvaluetemp |= uint64(dAtA[iNdEx-7]) << 8
					mapvaluetemp |= uint64(dAtA[iNdEx-6]) << 16
					mapvaluetemp |= uint64(dAtA[iNdEx-5]) << 24
					mapvaluetemp |= uint64(dAtA[iNdEx-4]) << 32
					mapvaluetemp |= uint64(dAtA[iNdEx-3]) << 40
					mapvaluetemp |= uint64(dAtA[iNdEx-2]) << 48
					mapvaluetemp |= uint64(dAtA[iNdEx-1]) << 56
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AAA[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BBB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BBB == nil {
				m.BBB = make(map[int64]float32)
			}
			var mapkey int64
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvaluetemp = uint32(dAtA[iNdEx-4])
					mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
					mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
					mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BBB[mapkey] = mapvalue
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CCC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CCC == nil {
				m.CCC = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CCC[mapkey] = mapvalue
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DDD == nil {
				m.DDD = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DDD[mapkey] = mapvalue
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EEE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EEE == nil {
				m.EEE = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EEE[mapkey] = mapvalue
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FFF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FFF == nil {
				m.FFF = make(map[int64]uint64)
			}
			var mapkey int64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FFF[mapkey] = mapvalue
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GGG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GGG == nil {
				m.GGG = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GGG[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HHH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HHH == nil {
				m.HHH = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HHH[mapkey] = mapvalue
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field III", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.III == nil {
				m.III = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = uint32(dAtA[iNdEx-4])
					mapvalue |= uint32(dAtA[iNdEx-3]) << 8
					mapvalue |= uint32(dAtA[iNdEx-2]) << 16
					mapvalue |= uint32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.III[mapkey] = mapvalue
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JJJ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JJJ == nil {
				m.JJJ = make(map[int64]uint64)
			}
			var mapkey int64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvalue = uint64(dAtA[iNdEx-8])
					mapvalue |= uint64(dAtA[iNdEx-7]) << 8
					mapvalue |= uint64(dAtA[iNdEx-6]) << 16
					mapvalue |= uint64(dAtA[iNdEx-5]) << 24
					mapvalue |= uint64(dAtA[iNdEx-4]) << 32
					mapvalue |= uint64(dAtA[iNdEx-3]) << 40
					mapvalue |= uint64(dAtA[iNdEx-2]) << 48
					mapvalue |= uint64(dAtA[iNdEx-1]) << 56
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JJJ[mapkey] = mapvalue
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KKK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KKK == nil {
				m.KKK = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = int32(dAtA[iNdEx-4])
					mapvalue |= int32(dAtA[iNdEx-3]) << 8
					mapvalue |= int32(dAtA[iNdEx-2]) << 16
					mapvalue |= int32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KKK[mapkey] = mapvalue
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LLL == nil {
				m.LLL = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LLL[mapkey] = mapvalue
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MMM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MMM == nil {
				m.MMM = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MMM[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMapMessageA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMapMessageA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMapMessageA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMapMessageC{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMapMessageB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMapMessageB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMapMessageB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = append(m.A, &NestedMapMessageC{})
			if err := m.A[len(m.A)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedMapMessageC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMapMessageC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMapMessageC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.A[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A == nil {
				m.A = &NestedMapMessageA{}
			}
			if err := m.A.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.B = append(m.B, &NestedMapMessageB{})
			if err := m.B[len(m.B)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AA == nil {
				m.AA = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvaluetemp = uint64(dAtA[iNdEx-8])
					mapvaluetemp |= uint64(dAtA[iNdEx-7]) << 8
					mapvaluetemp |= uint64(dAtA[iNdEx-6]) << 16
					mapvaluetemp |= uint64(dAtA[iNdEx-5]) << 24
					mapvaluetemp |= uint64(dAtA[iNdEx-4]) << 32
					mapvaluetemp |= uint64(dAtA[iNdEx-3]) << 40
					mapvaluetemp |= uint64(dAtA[iNdEx-2]) << 48
					mapvaluetemp |= uint64(dAtA[iNdEx-1]) << 56
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AA[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BB == nil {
				m.BB = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvaluetemp = uint32(dAtA[iNdEx-4])
					mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
					mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
					mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BB[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CC == nil {
				m.CC = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CC[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DD == nil {
				m.DD = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DD[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EE == nil {
				m.EE = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EE[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FF == nil {
				m.FF = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FF[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GG == nil {
				m.GG = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GG[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HH == nil {
				m.HH = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HH[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field II", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.II == nil {
				m.II = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = uint32(dAtA[iNdEx-4])
					mapvalue |= uint32(dAtA[iNdEx-3]) << 8
					mapvalue |= uint32(dAtA[iNdEx-2]) << 16
					mapvalue |= uint32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.II[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JJ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JJ == nil {
				m.JJ = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvalue = uint64(dAtA[iNdEx-8])
					mapvalue |= uint64(dAtA[iNdEx-7]) << 8
					mapvalue |= uint64(dAtA[iNdEx-6]) << 16
					mapvalue |= uint64(dAtA[iNdEx-5]) << 24
					mapvalue |= uint64(dAtA[iNdEx-4]) << 32
					mapvalue |= uint64(dAtA[iNdEx-3]) << 40
					mapvalue |= uint64(dAtA[iNdEx-2]) << 48
					mapvalue |= uint64(dAtA[iNdEx-1]) << 56
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JJ[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KK == nil {
				m.KK = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = int32(dAtA[iNdEx-4])
					mapvalue |= int32(dAtA[iNdEx-3]) << 8
					mapvalue |= int32(dAtA[iNdEx-2]) << 16
					mapvalue |= int32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KK[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LL == nil {
				m.LL = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LL[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MM == nil {
				m.MM = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MM[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AAA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AAA == nil {
				m.AAA = make(map[int64]float64)
			}
			var mapkey int64
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvaluetemp = uint64(dAtA[iNdEx-8])
					mapvaluetemp |= uint64(dAtA[iNdEx-7]) << 8
					mapvaluetemp |= uint64(dAtA[iNdEx-6]) << 16
					mapvaluetemp |= uint64(dAtA[iNdEx-5]) << 24
					mapvaluetemp |= uint64(dAtA[iNdEx-4]) << 32
					mapvaluetemp |= uint64(dAtA[iNdEx-3]) << 40
					mapvaluetemp |= uint64(dAtA[iNdEx-2]) << 48
					mapvaluetemp |= uint64(dAtA[iNdEx-1]) << 56
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AAA[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BBB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BBB == nil {
				m.BBB = make(map[int64]float32)
			}
			var mapkey int64
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvaluetemp = uint32(dAtA[iNdEx-4])
					mapvaluetemp |= uint32(dAtA[iNdEx-3]) << 8
					mapvaluetemp |= uint32(dAtA[iNdEx-2]) << 16
					mapvaluetemp |= uint32(dAtA[iNdEx-1]) << 24
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BBB[mapkey] = mapvalue
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CCC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CCC == nil {
				m.CCC = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CCC[mapkey] = mapvalue
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DDD == nil {
				m.DDD = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DDD[mapkey] = mapvalue
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EEE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EEE == nil {
				m.EEE = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EEE[mapkey] = mapvalue
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FFF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FFF == nil {
				m.FFF = make(map[int64]uint64)
			}
			var mapkey int64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FFF[mapkey] = mapvalue
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GGG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GGG == nil {
				m.GGG = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GGG[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HHH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HHH == nil {
				m.HHH = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HHH[mapkey] = mapvalue
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field III", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.III == nil {
				m.III = make(map[int64]uint32)
			}
			var mapkey int64
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = uint32(dAtA[iNdEx-4])
					mapvalue |= uint32(dAtA[iNdEx-3]) << 8
					mapvalue |= uint32(dAtA[iNdEx-2]) << 16
					mapvalue |= uint32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.III[mapkey] = mapvalue
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JJJ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JJJ == nil {
				m.JJJ = make(map[int64]uint64)
			}
			var mapkey int64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					mapvalue = uint64(dAtA[iNdEx-8])
					mapvalue |= uint64(dAtA[iNdEx-7]) << 8
					mapvalue |= uint64(dAtA[iNdEx-6]) << 16
					mapvalue |= uint64(dAtA[iNdEx-5]) << 24
					mapvalue |= uint64(dAtA[iNdEx-4]) << 32
					mapvalue |= uint64(dAtA[iNdEx-3]) << 40
					mapvalue |= uint64(dAtA[iNdEx-2]) << 48
					mapvalue |= uint64(dAtA[iNdEx-1]) << 56
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JJJ[mapkey] = mapvalue
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KKK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KKK == nil {
				m.KKK = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					mapvalue = int32(dAtA[iNdEx-4])
					mapvalue |= int32(dAtA[iNdEx-3]) << 8
					mapvalue |= int32(dAtA[iNdEx-2]) << 16
					mapvalue |= int32(dAtA[iNdEx-1]) << 24
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KKK[mapkey] = mapvalue
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LLL == nil {
				m.LLL = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LLL[mapkey] = mapvalue
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MMM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MMM == nil {
				m.MMM = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MMM[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapNestedMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapNestedMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapNestedMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Beta == nil {
				m.Beta = make(map[int64]*NestedMessageA)
			}
			var mapkey int64
			var mapvalue *NestedMessageA
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NestedMessageA{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Beta[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedTypes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AA = append(m.AA, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AA = append(m.AA, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AA", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BB = append(m.BB, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v EnumType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (EnumType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CC = append(m.CC, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v EnumType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (EnumType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CC = append(m.CC, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CC", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTest
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTest(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTest = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTest   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("test.proto", fileDescriptorTest) }

var fileDescriptorTest = []byte{
	// 1327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x99, 0xdf, 0x6e, 0xdb, 0x54,
	0x1c, 0xc7, 0x71, 0x4e, 0xd7, 0xba, 0x67, 0x6d, 0xd6, 0x99, 0x96, 0x1d, 0x55, 0xc3, 0x2b, 0x81,
	0x41, 0x29, 0x38, 0x31, 0x65, 0x58, 0x68, 0x77, 0xfe, 0x17, 0x27, 0x8e, 0x0d, 0x28, 0xf4, 0x05,
	0x3c, 0x66, 0xba, 0x89, 0x2d, 0x09, 0xb5, 0x03, 0x2a, 0x97, 0xbc, 0x00, 0x17, 0x3c, 0x05, 0x6f,
	0xc2, 0x25, 0x12, 0x3c, 0x00, 0x9a, 0xb8, 0xe7, 0x15, 0xd0, 0xcf, 0x39, 0xee, 0x7e, 0x75, 0x7d,
	0xce, 0x01, 0x09, 0x2e, 0x90, 0x7a, 0xd5, 0x3f, 0xf9, 0x7c, 0x7d, 0xa2, 0xf4, 0xb3, 0xf6, 0x13,
	0x8f, 0xd2, 0x32, 0x2f, 0xca, 0xfe, 0xe2, 0x6c, 0x5e, 0xce, 0x8d, 0xb5, 0x93, 0xf0, 0xf3, 0x93,
	0x7d, 0xff, 0xf4, 0x69, 0xf9, 0x64, 0xf9, 0xa8, 0xff, 0xc5, 0xfc, 0xf9, 0xe0, 0x64, 0x39, 0xcb,
	0x93, 0xec, 0xd1, 0xa0, 0x3c, 0x5b, 0x16, 0xc5, 0xe0, 0x71, 0xfe, 0x65, 0x79, 0x96, 0xe7, 0x83,
	0xd3, 0xf9, 0xfc, 0xf4, 0x59, 0x5e, 0x3e, 0x79, 0x7a, 0xf6, 0x78, 0x91, 0x9d, 0x95, 0xe7, 0x83,
	0x6c, 0x36, 0x9b, 0x97, 0x59, 0xf9, 0x74, 0x3e, 0x2b, 0x56, 0x97, 0xea, 0x9d, 0xd3, 0xdb, 0x9f,
	0xe4, 0x45, 0x99, 0x3f, 0x3e, 0x39, 0x5f, 0xe4, 0xd3, 0xfc, 0xeb, 0x65, 0x5e, 0x94, 0x46, 0x8f,
	0x6a, 0x2e, 0xd3, 0x0e, 0xb4, 0xc3, 0x9b, 0xc7, 0xbb, 0x7d, 0x38, 0xab, 0xbf, 0x62, 0xd2, 0xbc,
	0x28, 0xb2, 0xd3, 0xdc, 0x9d, 0x6a, 0x2e, 0x30, 0x1e, 0xbb, 0x7d, 0x40, 0x04, 0x8c, 0x37, 0xd5,
	0x3c, 0xe3, 0x2e, 0xd5, 0x7c, 0x66, 0x1c, 0x68, 0x87, 0xdd, 0xe3, 0xee, 0x8a, 0x09, 0x67, 0xcb,
	0xe7, 0xd5, 0x49, 0x9a, 0xdf, 0x7b, 0x40, 0xbb, 0x97, 0x2f, 0xab, 0x3a, 0xd7, 0x9f, 0x6a, 0xee,
	0x95, 0x95, 0x57, 0xaf, 0x88, 0x6c, 0x65, 0x36, 0x56, 0xbe, 0xb1, 0x55, 0x9f, 0x45, 0xe0, 0xf1,
	0xef, 0xa8, 0x81, 0x5f, 0x86, 0x62, 0x31, 0x9f, 0x15, 0xf9, 0xea, 0xca, 0x3b, 0xff, 0xf5, 0xeb,
	0xf0, 0xdb, 0x1e, 0xed, 0xa6, 0xd9, 0x02, 0xff, 0x00, 0xee, 0xbf, 0x7c, 0x21, 0xee, 0x5c, 0xba,
	0x68, 0xb6, 0xc0, 0x67, 0xdf, 0x87, 0xb3, 0x3b, 0xd5, 0xd9, 0x02, 0xac, 0x3a, 0xfe, 0x7d, 0xda,
	0x71, 0x5d, 0x76, 0xb3, 0xe2, 0xee, 0xae, 0xb8, 0xcb, 0xe7, 0xf5, 0x5d, 0x37, 0x9c, 0x95, 0x67,
	0xe7, 0xd3, 0x8e, 0xeb, 0x02, 0xed, 0x79, 0x6c, 0x4b, 0x42, 0x7b, 0x1e, 0xa7, 0xbd, 0xea, 0xda,
	0xbe, 0xcf, 0xb6, 0x25, 0xb4, 0xef, 0x73, 0xda, 0xf7, 0x81, 0x0e, 0x02, 0xd6, 0x95, 0xd0, 0x41,
	0xc0, 0xe9, 0x20, 0x00, 0x3a, 0x0c, 0xd9, 0x2d, 0x09, 0x1d, 0x86, 0x9c, 0x0e, 0x43, 0xa0, 0x87,
	0x43, 0xb6, 0x23, 0xa1, 0x87, 0x43, 0x4e, 0x0f, 0x87, 0x40, 0x47, 0x11, 0xff, 0xb9, 0xb5, 0xd3,
	0x51, 0xc4, 0xe9, 0x28, 0x02, 0x7a, 0x34, 0x62, 0x86, 0x84, 0x1e, 0x8d, 0x38, 0x3d, 0x1a, 0x01,
	0x3d, 0x1e, 0xb3, 0x57, 0x25, 0xf4, 0x78, 0xcc, 0xe9, 0xf1, 0x18, 0xe8, 0x38, 0x66, 0xbb, 0x12,
	0x3a, 0x8e, 0x39, 0x1d, 0xc7, 0x40, 0x4f, 0x26, 0x6c, 0x4f, 0x42, 0x4f, 0x26, 0x9c, 0x9e, 0x4c,
	0x80, 0x4e, 0x12, 0xf6, 0x9a, 0x84, 0x4e, 0x12, 0x4e, 0x27, 0x09, 0xd0, 0x69, 0xca, 0xee, 0x48,
	0xe8, 0x34, 0xe5, 0x74, 0x9a, 0x1a, 0x03, 0x4a, 0x5c, 0xd7, 0x65, 0xf7, 0x2a, 0xfc, 0x75, 0x81,
	0x56, 0xdc, 0x2b, 0x20, 0x61, 0xe0, 0x79, 0x1e, 0x3b, 0x90, 0x0c, 0xbc, 0x5a, 0x2d, 0x20, 0x61,
	0xe0, 0xfb, 0x3e, 0x7b, 0x43, 0x32, 0xf0, 0x6b, 0xbb, 0x80, 0x84, 0x41, 0x10, 0x04, 0xac, 0x27,
	0x19, 0x04, 0xb5, 0x60, 0x40, 0xc2, 0x20, 0x0c, 0x43, 0xf6, 0xa6, 0x64, 0x10, 0xd6, 0x8e, 0x01,
	0x09, 0x83, 0xe1, 0x70, 0xc8, 0xde, 0x92, 0x0c, 0x86, 0xb5, 0x66, 0x40, 0xc2, 0x20, 0x8a, 0x22,
	0x76, 0x5f, 0x32, 0x88, 0x6a, 0xd3, 0x80, 0x84, 0xc1, 0x68, 0x34, 0x62, 0x6f, 0x4b, 0x06, 0xa3,
	0x5a, 0x36, 0x20, 0x61, 0x30, 0x1e, 0x8f, 0xd9, 0x3b, 0x92, 0xc1, 0xb8, 0xf6, 0x0d, 0x48, 0x18,
	0xc4, 0x71, 0xcc, 0x0e, 0x25, 0x83, 0xb8, 0x56, 0x0e, 0x48, 0x18, 0x4c, 0x26, 0x13, 0xf6, 0xae,
	0x64, 0x30, 0xa9, 0xad, 0x03, 0x12, 0x06, 0x49, 0x92, 0xb0, 0x23, 0xc9, 0x20, 0xa9, 0xc5, 0x03,
	0x12, 0x06, 0x69, 0x9a, 0xb2, 0xf7, 0x24, 0x83, 0xb4, 0x76, 0x0f, 0xc8, 0xfd, 0x8f, 0xe8, 0x06,
	0x77, 0xcb, 0xd8, 0xa1, 0xe4, 0xab, 0xfc, 0xbc, 0xfa, 0x6d, 0xb9, 0x39, 0x85, 0x4f, 0x8d, 0x5d,
	0x7a, 0xe3, 0x9b, 0xec, 0xd9, 0x32, 0x67, 0x9d, 0x03, 0xed, 0x50, 0x9b, 0xae, 0xbe, 0x78, 0xd8,
	0xf9, 0x58, 0x83, 0x19, 0x37, 0x4c, 0x35, 0xeb, 0x34, 0x66, 0xdc, 0x33, 0xd5, 0xec, 0x46, 0x63,
	0xc6, 0x6d, 0x53, 0xcd, 0x48, 0x63, 0xc6, 0x9d, 0x53, 0xcd, 0xb6, 0x1b, 0x33, 0x6e, 0x9e, 0x6a,
	0xb6, 0xd6, 0x98, 0x71, 0xff, 0x54, 0xb3, 0xdb, 0x8d, 0x19, 0xb7, 0x50, 0x35, 0x33, 0x1a, 0x33,
	0xee, 0xa2, 0x6a, 0xb6, 0xd1, 0x98, 0x71, 0x23, 0x55, 0xb3, 0xf5, 0xc6, 0x8c, 0x7b, 0xa9, 0x9a,
	0xdd, 0x6a, 0xcc, 0xb8, 0x9d, 0xaa, 0x99, 0xde, 0x98, 0x71, 0x47, 0x55, 0xb3, 0x4d, 0x3c, 0x73,
	0xa8, 0xee, 0xb6, 0xb8, 0x4c, 0x54, 0x2e, 0x3b, 0x54, 0xf7, 0x5a, 0x64, 0x26, 0x2a, 0x99, 0x1d,
	0xaa, 0xfb, 0x2d, 0x36, 0x13, 0x95, 0xcd, 0x0e, 0xd5, 0x83, 0x16, 0x9d, 0x89, 0x4a, 0x67, 0x87,
	0xea, 0x61, 0x8b, 0xcf, 0x44, 0xe5, 0xb3, 0x43, 0xf5, 0x61, 0x8b, 0xd0, 0x44, 0x25, 0xb4, 0x43,
	0xf5, 0xa8, 0xc5, 0x68, 0xa2, 0x32, 0xda, 0xa1, 0xfa, 0xa8, 0x45, 0x69, 0xa2, 0x52, 0xda, 0xa1,
	0xfa, 0xb8, 0xc5, 0x69, 0xa2, 0x72, 0xda, 0xa1, 0x7a, 0xdc, 0x22, 0x35, 0x51, 0x49, 0xed, 0x50,
	0x7d, 0xd2, 0x62, 0x35, 0x51, 0x59, 0xed, 0x50, 0x3d, 0x69, 0xd1, 0x9a, 0xa8, 0xb4, 0x76, 0xa8,
	0x9e, 0xb6, 0x78, 0x4d, 0x14, 0x5e, 0xf7, 0x1e, 0xd6, 0xef, 0x2c, 0x50, 0xb4, 0xfe, 0x8d, 0xb0,
	0xad, 0x72, 0xbd, 0x65, 0xeb, 0xd5, 0x5b, 0xa2, 0xd8, 0x7e, 0x7b, 0x75, 0x0b, 0xe1, 0x79, 0xb1,
	0x35, 0x05, 0xdb, 0x3e, 0x6f, 0x15, 0xcd, 0xdd, 0x7f, 0x40, 0xd7, 0xdd, 0x7f, 0xfc, 0x0f, 0xb9,
	0xf7, 0xe7, 0x1e, 0xbd, 0x75, 0xf1, 0x47, 0x8b, 0xbf, 0x83, 0xf8, 0x77, 0x43, 0xde, 0x42, 0x21,
	0xdf, 0xfc, 0x2b, 0xb9, 0x3a, 0xf0, 0x52, 0xc9, 0x5b, 0xa8, 0xe4, 0x05, 0x38, 0x4e, 0x79, 0x0b,
	0xa5, 0xbc, 0x00, 0xc7, 0x2d, 0x6f, 0xa1, 0x96, 0x17, 0xe0, 0x38, 0xe6, 0x2d, 0x14, 0xf3, 0x02,
	0x1c, 0xd7, 0xbc, 0x85, 0x6a, 0x5e, 0x80, 0xe3, 0x9c, 0xb7, 0x50, 0xce, 0x0b, 0x70, 0xdc, 0xf3,
	0x16, 0xea, 0x79, 0x01, 0x8e, 0x83, 0xde, 0x42, 0x41, 0x2f, 0xc0, 0x71, 0xd1, 0x5b, 0xa8, 0xe8,
	0x05, 0x38, 0x4e, 0x7a, 0x0b, 0x25, 0xbd, 0x00, 0xc7, 0x4d, 0x6f, 0xa1, 0xa6, 0x17, 0xe0, 0x38,
	0xea, 0x2d, 0x14, 0xf5, 0x02, 0x1c, 0x57, 0xbd, 0x8d, 0xab, 0xde, 0x14, 0x39, 0x86, 0xb3, 0xde,
	0xc6, 0x59, 0x6f, 0x8a, 0x34, 0xc3, 0x5d, 0x6f, 0xe3, 0xae, 0x37, 0x45, 0xa6, 0xe1, 0xb0, 0xb7,
	0x71, 0xd8, 0x9b, 0x22, 0xd9, 0x70, 0xd9, 0xdb, 0xb8, 0xec, 0x4d, 0xa1, 0x6f, 0x28, 0xed, 0x6d,
	0x9c, 0xf6, 0xa6, 0x48, 0x39, 0xdc, 0xf6, 0x36, 0x6e, 0x7b, 0x53, 0x64, 0x1d, 0x8e, 0x7b, 0x1b,
	0xc7, 0xbd, 0x29, 0x12, 0x0f, 0xd7, 0xbd, 0x8d, 0xeb, 0xde, 0x14, 0xb9, 0x87, 0xf3, 0xde, 0xc6,
	0x79, 0x6f, 0x8a, 0xf4, 0xc3, 0x7d, 0x6f, 0xe3, 0xbe, 0x37, 0x45, 0x06, 0xe2, 0xc0, 0xb7, 0x71,
	0xe0, 0x9b, 0x22, 0x09, 0x71, 0xe1, 0xdb, 0xb8, 0xf0, 0x4d, 0x91, 0x87, 0xd7, 0x89, 0x7f, 0x9d,
	0xf8, 0xd7, 0x89, 0x7f, 0x9d, 0xf8, 0xd7, 0x89, 0xff, 0xbf, 0x48, 0xfc, 0x1f, 0x34, 0xba, 0x95,
	0x66, 0x0b, 0xde, 0xaa, 0xc5, 0xa9, 0x61, 0xd3, 0x35, 0x2f, 0x2f, 0x33, 0x9e, 0xb2, 0x2f, 0xef,
	0x21, 0x5e, 0x10, 0x7d, 0x78, 0x78, 0xf5, 0x4b, 0xbe, 0x22, 0xf7, 0x53, 0xba, 0x79, 0xf1, 0xad,
	0x96, 0xb3, 0x8f, 0xf0, 0xd9, 0xa2, 0xbb, 0xf0, 0xe8, 0x19, 0x7d, 0x4a, 0xb7, 0xa7, 0xf9, 0x22,
	0xcf, 0xf8, 0x9d, 0xfc, 0xc2, 0xe8, 0x56, 0xc9, 0x0c, 0xe5, 0x4f, 0xaa, 0x26, 0xee, 0x56, 0x4d,
	0x0c, 0xcf, 0x6f, 0xb3, 0x8a, 0x5e, 0xb3, 0x8a, 0x5e, 0x72, 0x40, 0x5a, 0xee, 0xcd, 0x77, 0x7c,
	0xff, 0xe8, 0x1e, 0xd5, 0xeb, 0xaf, 0x8d, 0x1b, 0x54, 0x73, 0x77, 0x5e, 0x81, 0x0f, 0xde, 0x8e,
	0x06, 0x1f, 0xfc, 0x9d, 0xce, 0xf1, 0x4f, 0x1d, 0x4a, 0xd2, 0x6c, 0x61, 0xb8, 0x74, 0x3d, 0xca,
	0x4b, 0xf8, 0x6c, 0xb7, 0xed, 0xfe, 0xd5, 0xfe, 0x5e, 0xeb, 0xdf, 0xbc, 0x1e, 0xfd, 0xfe, 0xd7,
	0x3f, 0x7e, 0xec, 0xac, 0x19, 0x9d, 0xc1, 0x07, 0x46, 0x40, 0x37, 0x3e, 0x9b, 0x17, 0x92, 0x6b,
	0xb4, 0x7e, 0xb7, 0xb7, 0x5d, 0x5d, 0x62, 0xa3, 0xd7, 0x19, 0x1c, 0x3f, 0xd4, 0x8e, 0x8c, 0x98,
	0x6e, 0x46, 0x79, 0xb9, 0x7a, 0x89, 0x8c, 0x4b, 0xef, 0x26, 0xf0, 0xa5, 0xd8, 0xd5, 0x07, 0x5a,
	0x9e, 0x51, 0x4a, 0x29, 0x3c, 0x23, 0xd5, 0xc5, 0x44, 0x0f, 0x34, 0x9e, 0x9a, 0xb7, 0xf5, 0xf3,
	0x0b, 0x53, 0xfb, 0xe5, 0x85, 0xa9, 0xfd, 0xfe, 0xc2, 0xd4, 0x1e, 0xad, 0x57, 0xff, 0x03, 0xf5,
	0xe1, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf0, 0xe2, 0xb1, 0x93, 0xda, 0x1a, 0x00, 0x00,
}
